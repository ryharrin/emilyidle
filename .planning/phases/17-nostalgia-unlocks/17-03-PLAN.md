---
phase: 17-nostalgia-unlocks
plan: 3
type: execute
wave: 3
depends_on: ["17-01", "17-02"]
files_modified:
  - tests/nostalgia-unlocks.unit.test.tsx
  - tests/nostalgia-unlocks.spec.ts
autonomous: true

must_haves:
  truths:
    - "Unit tests lock nostalgia unlock cost/order/refund semantics"
    - "Unit tests verify prestigeNostalgia preserves nostalgiaUnlockedItems"
    - "Playwright verifies the Unlocks UI flow and that a purchased unlock makes a watch purchasable in Vault"
    - "Playwright asserts the Nostalgia tab remains visible after an unlock purchase that spends nostalgia points to 0"
  artifacts:
    - path: tests/nostalgia-unlocks.unit.test.tsx
      provides: "Unit coverage for unlock domain helpers"
    - path: tests/nostalgia-unlocks.spec.ts
      provides: "E2E coverage for unlock store and milestone-bypass behavior"
  key_links:
    - from: tests/nostalgia-unlocks.spec.ts
      to: src/App.tsx
      via: data-testid hooks
      pattern: "nostalgia-unlock-"
    - from: tests/nostalgia-unlocks.unit.test.tsx
      to: src/game/state.ts
      via: domain helpers
      pattern: "buyNostalgiaUnlock\(|refundNostalgiaUnlock\("
---

<objective>
Add unit + e2e coverage for nostalgia unlocks to prevent regressions in unlock semantics, persistence behavior, and the Nostalgia tab UI.

Purpose: Keep the new meta-progression loop reliable and safe to refactor in later phases.
Output: New Vitest + Playwright tests that pass in CI.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@tests/nostalgia-prestige.unit.test.tsx
@tests/nostalgia-prestige.spec.ts

@src/game/state.ts
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Vitest unit coverage for nostalgia unlock rules</name>
  <files>tests/nostalgia-unlocks.unit.test.tsx</files>
  <action>
Create `tests/nostalgia-unlocks.unit.test.tsx` following existing Vitest style.

Cover these behaviors using `createInitialState()` and the new helpers:
- Costs are stable and unique: classic=1, chronograph=3, tourbillon=6.
- Unlocks are unavailable before first prestige (`nostalgiaResets < 1`).
- Order is enforced:
  - Can buy classic first.
  - Cannot buy chronograph until classic is nostalgia-unlocked (milestones do not advance nostalgia unlock order).
  - Cannot buy tourbillon until chronograph is nostalgia-unlocked.
- Buying an unlock:
  - Subtracts nostalgia points by cost.
  - Adds id into `nostalgiaUnlockedItems` with deterministic order.
- Refund rules:
  - Only the most recent unlock (highest unlocked in the order) can be refunded.
  - Refund returns 100% of cost and removes id.
- `isItemUnlocked` OR gate:
  - When `nostalgiaUnlockedItems` contains an id, `isItemUnlocked` is true even when milestone is missing.
- Prestige persistence:
  - Seed a state with `nostalgiaUnlockedItems: ["classic"]`, call `prestigeNostalgia(...)`, and assert the unlock list is unchanged.

Keep the tests resilient: avoid asserting on exact UI copy; test only domain behavior.
  </action>
  <verify>pnpm run test:unit</verify>
  <done>
All unit tests pass and cover order gating, affordability, purchase, refund, and `isItemUnlocked` behavior.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Playwright coverage for unlock UI + milestone-bypass purchasability</name>
  <files>tests/nostalgia-unlocks.spec.ts</files>
  <action>
Create `tests/nostalgia-unlocks.spec.ts` following the `tests/nostalgia-prestige.spec.ts` patterns.

Seed a save in `page.addInitScript` with:
- `nostalgiaResets: 1` and `nostalgiaPoints: 1` (so buying Classic spends to 0).
- Enough `currencyCents` and `enjoymentCents` to buy a Classic if it were unlocked.
- `unlockedMilestones: []` (or at least omit the milestone that unlocks Classic) so Classic starts milestone-locked.

Test flow:
1. Visit `/`, open the Nostalgia tab.
2. Assert unlock store wrapper visible: `nostalgia-unlocks`.
3. Assert Classic buy is available and Chronograph buy is disabled due to order.
4. Click Classic buy.
   - If confirmation toggle defaults ON, assert `nostalgia-unlock-modal` appears and confirm.
5. Assert Classic card shows an Unlocked state and a Refund button.
6. Switch to Vault tab and assert Classic purchase is now enabled (milestone gate bypassed) by checking that the Classic buy button is not disabled.
   - Prefer `data-testid="vault-buy-classic"` (added in 17-02) over text/price locators.
7. Assert the Nostalgia tab stays available after spending to 0:
   - Seed `nostalgiaPoints` so buying Classic spends the balance down to 0.
   - After purchase, assert the tab button remains visible (e.g., `getByTestId("nostalgia-tab")` is visible) and the Nostalgia panel can still be opened.
8. (Optional but valuable) Trigger a refund and confirm nostalgia balance/status updates accordingly.

Use the new `data-testid` hooks (not fragile text selectors) whenever possible.
  </action>
  <verify>pnpm run test:e2e</verify>
  <done>
Playwright validates the Nostalgia unlock store flow and confirms that unlocking makes the watch purchasable despite missing milestone gates.
  </done>
</task>

</tasks>

<verification>
- `pnpm run test:unit`
- `pnpm run test:e2e`
</verification>

<success_criteria>
- Tests pass locally and enforce the core unlock invariants (order, refunds, persistence behavior via UI).
</success_criteria>

<output>
After completion, create `.planning/phases/17-nostalgia-unlocks/17-03-SUMMARY.md`
</output>
