---
phase: 17-nostalgia-unlocks
plan: 1
type: execute
wave: 1
depends_on: []
files_modified:
  - src/game/state.ts
  - src/game/persistence.ts
autonomous: true

must_haves:
  truths:
    - "Nostalgia unlocks persist across reloads and prestige resets"
    - "A nostalgia unlock makes the watch purchasable even without its milestone gate"
    - "Unlock purchases spend nostalgia points and refunds return the full cost"
  artifacts:
    - path: src/game/state.ts
      provides: "nostalgiaUnlockedItems persistence + unlock purchase/refund helpers + isItemUnlocked OR gate"
    - path: src/game/persistence.ts
      provides: "save v2 sanitization accepts nostalgiaUnlockedItems as optional field"
  key_links:
    - from: src/game/state.ts
      to: src/game/state.ts
      via: isItemUnlocked
      pattern: "nostalgiaUnlockedItems"
    - from: src/game/persistence.ts
      to: src/game/state.ts
      via: createStateFromSave
      pattern: "createStateFromSave\(persisted\)"
---

<objective>
Add a persisted nostalgia unlock list and pure state helpers for purchasing/refunding unlocks, and wire unlocks into the global unlock gate so unlocked watch types become buyable across runs.

Purpose: Enable Phase 17's meta-progression loop where nostalgia points unlock watch types permanently.
Output: Backwards compatible save data + deterministic unlock logic used by UI and tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/17-nostalgia-unlocks/17-CONTEXT.md
@.planning/phases/17-nostalgia-unlocks/17-RESEARCH.md

@src/game/state.ts
@src/game/persistence.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Persist nostalgiaUnlockedItems in GameState + save v2 (backwards compatible)</name>
  <files>src/game/state.ts, src/game/persistence.ts</files>
  <action>
Add a new meta-progression field:
- In `src/game/state.ts`, add `nostalgiaUnlockedItems: WatchItemId[]` to `GameState`.
- In `src/game/state.ts`, add `nostalgiaUnlockedItems?: string[]` to `PersistedGameState` (optional!).
- In `src/game/state.ts` `createInitialState()`, default `nostalgiaUnlockedItems: []`.
- In `src/game/state.ts` `createStateFromSave(...)`, parse `saved.nostalgiaUnlockedItems`:
  - Accept only known `WatchItemId` values.
  - De-dupe.
  - Re-encode into deterministic canonical order matching `WATCH_ITEMS` definition order.
- In `src/game/persistence.ts` `sanitizeState(...)`, pass through `record.nostalgiaUnlockedItems` when it is an array of strings; otherwise omit it so old saves keep working.

Do NOT change the localStorage key or save version; keep save v2 compatible with missing fields.
  </action>
  <verify>pnpm run typecheck</verify>
  <done>
Typecheck passes, old saves load with `nostalgiaUnlockedItems` defaulting to `[]`, and new saves include the field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement nostalgia unlock rules (costs, order enforcement, refunds) and wire into isItemUnlocked</name>
  <files>src/game/state.ts</files>
  <action>
Implement the Phase 17 unlock system in `src/game/state.ts` as pure helpers used by UI/tests:

- Define unlockable watch ids and order:
  - `const NOSTALGIA_UNLOCK_ORDER: WatchItemId[] = ["classic", "chronograph", "tourbillon"];`
  - Unlocks are only available after first nostalgia prestige: `state.nostalgiaResets >= 1`.
- Define per-watch nostalgia costs (unique per unlock) as constants:
  - `classic: 1`, `chronograph: 3`, `tourbillon: 6`.
  - Export `getNostalgiaUnlockCost(id)` and `getNostalgiaUnlockIds()`.
- Implement purchasing:
  - `canBuyNostalgiaUnlock(state, id)` returns false when:
    - `state.nostalgiaResets < 1`
    - `id` not in unlock list
    - already nostalgia-unlocked
    - does not satisfy order (must be the first not-yet-unlocked id in `NOSTALGIA_UNLOCK_ORDER`; allow prerequisite satisfied via milestone OR nostalgia unlock by checking `isItemUnlocked` *for prerequisite ids*).
    - insufficient nostalgia points
  - `buyNostalgiaUnlock(state, id)` returns unchanged state if cannot buy; otherwise subtract cost and add id to `nostalgiaUnlockedItems` in canonical order.
- Implement refunds (respec):
  - `canRefundNostalgiaUnlock(state, id)` true only when `id` is nostalgia-unlocked AND it is the last unlocked item in `NOSTALGIA_UNLOCK_ORDER` (reverse-order refunds preserve the enforced unlock order).
  - `refundNostalgiaUnlock(state, id)` returns unchanged state if cannot refund; otherwise add full cost back and remove id from `nostalgiaUnlockedItems`.
- Update `isItemUnlocked(state, id)` to be an OR gate:
  - unlocked if no milestone gate OR milestone achieved OR `state.nostalgiaUnlockedItems.includes(id)`.

Keep the existing dual-currency purchase rules intact; the nostalgia unlock bypasses milestone gate only.
  </action>
  <verify>pnpm run typecheck</verify>
  <done>
`isItemUnlocked` treats nostalgia unlocks as unlocked, and unlock buy/refund helpers enforce unlock order, affordability, and 100% refunds.
  </done>
</task>

</tasks>

<verification>
- `pnpm run typecheck`
</verification>

<success_criteria>
- `GameState` and save v2 persist `nostalgiaUnlockedItems` without breaking older saves.
- Domain helpers exist for costs + buy/refund + order gating, and `isItemUnlocked` includes the nostalgia-unlock OR rule.
</success_criteria>

<output>
After completion, create `.planning/phases/17-nostalgia-unlocks/17-01-SUMMARY.md`
</output>
