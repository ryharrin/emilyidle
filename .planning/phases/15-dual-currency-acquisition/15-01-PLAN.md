---
phase: 15-dual-currency-acquisition
plan: 1
type: execute
wave: 1
depends_on: []
files_modified:
  - src/game/state.ts
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "A watch purchase is allowed only when cash >= cash price and enjoyment >= enjoyment requirement"
    - "Enjoyment is never spent by buying watches"
    - "When both cash and enjoyment are insufficient, the computed purchase block reason prioritizes enjoyment"
    - "Auto-buy cannot buy watches that are enjoyment-locked"
  artifacts:
    - path: "src/game/state.ts"
      provides: "Cash purchase curve + enjoyment gate for watch purchases"
      exports: ["getWatchPurchaseGate"]
      contains: "type WatchPurchaseGate"
    - path: "src/App.tsx"
      provides: "Auto-buy purchase loop uses shared purchase helpers"
      contains: "getMaxAffordableItemCount"
  key_links:
    - from: "src/game/state.ts"
      to: "buyItem"
      via: "shared getWatchPurchaseGate helper"
      pattern: "getWatchPurchaseGate\(state, id"
    - from: "src/game/state.ts"
      to: "getMaxAffordableItemCount"
      via: "returns 0 when enjoyment insufficient"
      pattern: "getMaxAffordableItemCount[\s\S]*getWatchPurchaseGate"
    - from: "src/App.tsx"
      to: "buyItem / getMaxAffordableItemCount"
      via: "auto-buy tick loop"
      pattern: "getMaxAffordableItemCount\\(.*item\\.id|buyItem\\(.*item\\.id"
---

<objective>
Implement the dual-gate purchase rule in game logic (cash spent, enjoyment threshold).

Purpose: Centralize the new acquisition rules so UI and auto-buy cannot drift.
Output: New purchase eligibility helper and updated purchase entry points in `src/game/state.ts`.
Output: Wire auto-buy in `src/App.tsx` through the same helpers so gating cannot be bypassed.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/15-dual-currency-acquisition/15-CONTEXT.md
@.planning/phases/15-dual-currency-acquisition/15-RESEARCH.md

@src/game/state.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add new cash curve + per-watch enjoyment requirements + purchase gate helper</name>
  <files>src/game/state.ts</files>
  <action>
    Implement Phase 15 purchase gating as a single exported helper used everywhere.

    1) Update watch cash purchase curve (locked decision: new tier-based curve; do not keep the old values as-is):
       - In the `WATCH_ITEMS` definitions, update `basePriceCents` and `priceGrowth` to the Phase 15 curve below.
       - Keep the existing series pricing behavior (geometric series via `getSeriesTotal`) and keep prices as pure constants
         (no event/upgrade multipliers).

       Use these Phase 15 cash curve constants:
       - starter: basePriceCents = 125, priceGrowth = 1.145
       - classic: basePriceCents = 1_800, priceGrowth = 1.17
       - chronograph: basePriceCents = 12_500, priceGrowth = 1.18
       - tourbillon: basePriceCents = 150_000, priceGrowth = 1.195

    2) Add explicit per-watch enjoyment requirements (locked decision: threshold only; not spent; starter has no gate):
       - Add a constant table keyed by `WatchItemId`:
         - starter: 0
         - classic: 2_000
         - chronograph: 15_000
         - tourbillon: 60_000
       - Treat enjoyment requirement as a per-watch threshold independent of quantity (bulk buys do not increase the threshold).

    3) Add a new exported type + function:
       - `export type WatchPurchaseGate = ...` (discriminated union) with fields:
         - ok
         - cashPriceCents
         - enjoymentRequiredCents
         - blocksBy ("enjoyment" | "cash") when ok=false
         - optional enjoymentDeficitCents, cashDeficitCents (for UI copy / tests)
       - `export function getWatchPurchaseGate(state: GameState, id: WatchItemId, quantity = 1): WatchPurchaseGate`
       - The helper must:
         - Compute `cashPriceCents` using existing `getItemPriceCents(state, id, quantity)`.
         - Compute `enjoymentRequiredCents` from the explicit requirement table (not derived).
         - Compute deficits (only when insufficient):
           - cashDeficitCents = cashPriceCents - state.currencyCents
           - enjoymentDeficitCents = enjoymentRequiredCents - state.enjoymentCents
         - Apply the locked priority rule: if enjoyment is insufficient (even if cash is also insufficient), blocksBy MUST be
           "enjoyment".
  </action>
  <verify>pnpm run typecheck</verify>
  <done>
    `src/game/state.ts` exports `getWatchPurchaseGate`, and it encodes the Phase 15 cash curve + explicit enjoyment
    requirements with enjoyment-priority blocking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire the gate through canBuyItem, buyItem, and max-affordable helpers</name>
  <files>
src/game/state.ts
src/App.tsx
  </files>
  <action>
    Ensure every watch purchase entry point enforces the same dual-gate rule.

    - Update `canBuyItem(state, id, quantity)` to return true only when BOTH are true:
      - `isItemUnlocked(state, id)`
      - `getWatchPurchaseGate(state, id, quantity).ok === true`

    - Update `buyItem(state, id, quantity)`:
      - Keep the existing guards (`quantity <= 0`, `!isItemUnlocked`) and add the enjoyment gate.
      - If `getWatchPurchaseGate(...)` is not ok, return state unchanged.
      - Spend ONLY `currencyCents` (cash). Do NOT modify `enjoymentCents`.
      - Keep existing discovery + milestone/achievement application logic.

    - Update `getMaxAffordableItemCount(state, id)`:
      - If `!isItemUnlocked(state, id)`, return 0.
      - If `getWatchPurchaseGate(state, id, 1)` blocks by enjoyment, return 0.
      - Otherwise, keep the existing cash-only max count logic.

    - Explicitly verify auto-buy cannot bypass gating:
      - Locate all auto-buy purchase call sites (search for `autoBuyEnabled`, `autoBuy`, and `getMaxAffordableItemCount(`).
      - Confirm auto-buy uses the shared helpers (NOT direct `state.currencyCents` comparisons to decide purchases, and NOT any direct mutation of watch counts/currency):
        - uses `getMaxAffordableItemCount(state, item.id)` to choose quantity; if it returns 0, auto-buy skips.
        - executes purchases via `buyItem(state, item.id, qty)` (which now enforces `getWatchPurchaseGate`).
      - If any auto-buy call site purchases watches without going through `buyItem`/`getMaxAffordableItemCount`, refactor it to do so.

    - Do NOT apply enjoyment gating to upgrades, workshop, maison, etc. Phase 15 scope is watch purchases only.
  </action>
  <verify>pnpm run test:unit</verify>
  <done>
    Manual buy and auto-buy both refuse enjoyment-locked watch purchases; buying a watch never changes
    `state.enjoymentCents`.
  </done>
</task>

</tasks>

<verification>
- `pnpm run test:unit` passes
- `pnpm run typecheck` passes
</verification>

<success_criteria>
- `getWatchPurchaseGate` exists and is used by `canBuyItem`, `buyItem`, and `getMaxAffordableItemCount`
- Watch purchases require both cash and enjoyment, but only cash is spent
- When both cash and enjoyment are insufficient, the gate reports `blocksBy: "enjoyment"`
</success_criteria>

<output>
After completion, create `.planning/phases/15-dual-currency-acquisition/15-01-SUMMARY.md`
</output>
