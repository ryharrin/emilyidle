---
phase: 01-foundation
plan: 02
type: execute
domain: game-loop
---

<objective>
Implement the minimal playable core loop: currency accrues over time and the player can buy something that increases income.

Purpose: Establish deterministic simulation + UI rendering patterns that all later content builds on.
Output: A visible ticking economy with at least one purchase that increases income rate.
</objective>

<execution_context>
~/.config/opencode/get-shit-done/workflows/execute-phase.md
~/.config/opencode/get-shit-done/templates/summary.md
~/.config/opencode/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

# Source context (current code)
@src/main.ts
@src/game/state.ts
@src/game/sim.ts
@src/game/format.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire deterministic simulation runtime (fixed timestep, accumulator)</name>
  <files>src/main.ts, src/game/sim.ts, src/game/state.ts</files>
  <action>
    Connect the existing pure simulation step to a real runtime loop.

    Requirements:
    - Use `step(state, dtMs)` from `src/game/sim.ts` as the ONLY place where time-based accrual happens.
    - Implement a fixed-timestep runtime using an accumulator so simulation speed is independent of display refresh rate.
      - Use `requestAnimationFrame` as the clock signal.
      - Maintain `lastFrameAtMs` and `accumulatorMs`.
      - Each frame: `accumulatorMs += elapsedMs` (clamped), then while `accumulatorMs >= SIM_TICK_MS`, advance state via `step(state, SIM_TICK_MS)`.
    - Clamp big frame deltas so background-tab throttling does not create an explosive single-frame catch-up.

    Avoid (and why):
    - Avoid running simulation directly in `setInterval` based on assumed accuracy; browsers throttle timers heavily in background tabs.
    - Avoid reading `Date.now()` inside `step`; determinism requires time to be an input.

    Implementation notes:
    - Keep state as a single in-memory `let state: GameState` for now (no persistence yet; that’s plan 01-03).
    - This task should NOT add upgrades, catalogs, prestige, or any complex mechanics.
  </action>
  <verify>
    - Run: `pnpm run typecheck`
    - Run: `pnpm run build`
    - Manual: Load the app and confirm currency increases steadily over time.
  </verify>
  <done>
    App advances `GameState` via fixed-timestep stepping; currency increases smoothly and consistently over time.
  </done>
</task>

<task type="auto">
  <name>Task 2: Render core stats + implement a buy action that increases income</name>
  <files>src/main.ts, src/game/state.ts, src/game/format.ts</files>
  <action>
    Add a minimal UI and a single purchase action.

    Requirements:
    - Display:
      - Current currency (formatted)
      - Current income rate (formatted per-second)
      - Owned item count
    - Add one purchasable item (“Basic watch” is fine) with:
      - A computed price based on current `itemCount` (simple scaling curve)
      - A buy button that is disabled when unaffordable
      - On purchase: decrease currency, increment `itemCount`, increase `incomeRateCentsPerSec`

    Suggested pricing (keep deterministic and simple):
    - `priceCents = ceil(basePriceCents * (1.15 ** itemCount))`
    - Choose a base price that allows the first purchase within ~5–15 seconds at the initial income rate.

    UI/event handling constraints:
    - Avoid re-binding click handlers every tick.
    - Keep rendering and state updates separate:
      - Simulation changes state.
      - UI reads current state and updates DOM.

    Avoid:
    - Multiple item types, upgrades, softcaps, prestige (those are Phase 2+).
  </action>
  <verify>
    - Manual: Let currency tick up; buy the item; confirm currency decreases and income rate increases.
    - Manual: Confirm buy is disabled when currency < price.
    - Run: `pnpm run build`
  </verify>
  <done>
    The player can buy an item; income increases; UI updates immediately and buy gating works.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Playable ticking economy + buy action (no saving yet)</what-built>
  <how-to-verify>
    1. Run: `pnpm run dev`
    2. Visit: the local dev URL printed by Vite
    3. Confirm currency increases over time (pace stays consistent)
    4. Confirm the buy button is disabled when unaffordable
    5. Wait until affordable; click buy; confirm currency decreases and income rate increases
    6. Leave the tab for ~30 seconds, return; confirm behavior is sensible (no massive jump)
  </how-to-verify>
  <resume-signal>Type "approved" to proceed to the next plan, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring this plan complete:
- [ ] `pnpm run typecheck` succeeds
- [ ] `pnpm run build` succeeds
- [ ] Core loop works in browser: tick + buy + income increase
</verification>

<success_criteria>
- Deterministic simulation runtime exists (fixed timestep + accumulator)
- UI shows core stats and allows purchase
- Buy action changes future income rate and is gated by affordability
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` with:
- Where state lives and how tick scheduling works
- What the first purchasable is and its pricing curve
- Files created/modified
</output>
