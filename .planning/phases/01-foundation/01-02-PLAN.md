---
phase: 01-foundation
plan: 02
type: execute
domain: game-loop
---

<objective>
Implement the minimal playable core loop: currency accrues over time and the player can buy something that increases income.

Purpose: Establish deterministic simulation + UI rendering patterns that all later content builds on.
Output: A visible ticking economy with at least one purchase that increases income rate.
</objective>

<execution_context>
~/.config/opencode/get-shit-done/workflows/execute-phase.md
~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define core game state and deterministic simulation step</name>
  <files>src/* (new or modified), (wherever the scaffold’s main entry lives)</files>
  <action>
    Create a small, explicit game state model and a pure simulation step function.

    Requirements:
    - State contains at minimum: currency, incomeRate, and a count of a purchasable item.
    - Implement `step(state, dtMs)` (or equivalent) as a pure function (no Date.now reads inside).
    - Use fixed-timestep simulation (e.g., 50ms or 100ms steps) or an accumulator approach for determinism.
    - Clamp large `dtMs` to prevent huge single-step jumps.

    Avoid:
    - Relying on `setInterval` to mean "exactly once per second".
    - Updating game speed based on frame rate; ensure high-refresh displays don’t run faster.
  </action>
  <verify>
    - Run: `npm run build`
    - Manual: Load the app and observe currency increasing steadily over time.
  </verify>
  <done>
    Currency increases as a function of incomeRate; code has a clear separation between simulation and rendering.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement UI rendering and a buy action that affects income</name>
  <files>src/* (UI files), any state/store module you introduce</files>
  <action>
    Render the core numbers and add a single purchase action.

    Requirements:
    - Display currency, income rate, and owned item count.
    - Provide a buy button with a cost; buying reduces currency and increases income rate.
    - Disable buy action when the player can’t afford it.
    - Keep actions explicit and state updates predictable.

    Avoid:
    - Adding multiple systems (upgrades, catalogs, prestige) in this plan.
  </action>
  <verify>
    - Manual: Let currency tick up; buy the item; confirm income rate increases and future currency accrues faster.
    - Run: `npm run build`
  </verify>
  <done>
    The player can buy an item; income increases; UI reflects changes immediately.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Playable ticking economy + buy action (no saving yet)</what-built>
  <how-to-verify>
    1. Run: `npm run dev`
    2. Visit: the local dev URL shown in terminal
    3. Confirm currency increases over time (consistent pace)
    4. Click buy when affordable; confirm currency decreases and income rate increases
    5. Confirm buy is disabled when unaffordable
    6. Leave tab for ~30 seconds and come back; confirm it still behaves sensibly (no explosive jump)
  </how-to-verify>
  <resume-signal>Type "approved" to proceed to the next plan, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring this plan complete:
- [ ] `npm run build` succeeds
- [ ] Core loop works in browser: tick + buy + income increase
</verification>

<success_criteria>
- Deterministic simulation step exists
- UI shows core stats and allows purchase
- Buy action changes future income rate
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` with:
- Where state lives and how step/tick scheduling works
- Any conventions established (e.g., fixed timestep)
- Files created/modified
</output>
